<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Language Reference</title><meta name="description" content="The detailed outline on Qupa's syntax"><meta name="keywords" content="Specification, Qupa"><meta property="og:title" content="Language Reference"><meta property="og:description" content="The detailed outline on Qupa's syntax"><meta property="og:type" content="article"><meta property="og:url" content="https://www.qupa.com/doc/language-reference.html"><meta property="og:process.env.SITE_NAME" content="Qupa"><meta property="og:tag" content="Specification, Qupa"><meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#d81b60">

<link rel="stylesheet" type="text/css" href="/style/main.css">

<script src="/script/main.js"></script></head><body><header>
	<a href="/index.html" style="float: left;">Home</a>
	<a href="/tag/article.html" style="float: left;">Feed</a>
	<a style="float: right;">Qupa</a>
</header><div class="wrapper"><h1>Language Reference</h1><p><strong>Index:</strong></p>
<blockquote>
<ul>
<li><a href="#Abstract">Abstract</a></li>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Comment">Comment</a><ul>
<li><a href="#Comment-Single-Line">Single Line</a></li>
<li><a href="#Comment-Multi-Line">Multi Line</a></li>
</ul>
</li>
<li><a href="#Constant">Constants</a><ul>
<li><a href="#Constant-Integer">Integer</a></li>
<li><a href="#Constant-Double">Double</a></li>
<li><a href="#Constant-Text">Text</a></li>
</ul>
</li>
<li><a href="#Function">Function</a><ul>
<li><a href="#Function-Argument">Argument</a><ul>
<li><a href="#Function-Argument-Default">Default</a></li>
<li><a href="#Function-Argument-Upgrade">Upgrade</a></li>
</ul>
</li>
<li><a href="#Function-Method">Method</a></li>
<li><a href="#Function-Template">Template</a></li>
<li><a href="#Function-Modifier">Modifier</a><ul>
<li><a href="#Function-Modifier-Async">Async</a></li>
<li><a href="#Function-Modifier-Inline">Inline</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Declare">Declare</a></li>
<li><a href="#Assign">Assign</a><ul>
<li><a href="#Assign-Short-Hand">Short Hand</a></li>
</ul>
</li>
<li><a href="#If-statement">If statement</a><ul>
<li><a href="#If-Elif">Elif statement</a></li>
<li><a href="#If-Else">Else statement</a></li>
</ul>
</li>
<li><a href="#Loop">Loop</a><ul>
<li><a href="#Loop-For">For</a></li>
<li><a href="#Loop-While">White</a></li>
<li><a href="#Loop-Break">Break</a></li>
<li><a href="#Loop-Continue">Continue</a></li>
</ul>
</li>
<li><a href="#Expression">Expression</a></li>
<li><a href="#Import">Import</a><ul>
<li><a href="#Import-Direct">Import Direct</a></li>
<li><a href="#Import-As">Import As</a></li>
</ul>
</li>
<li><a href="#Expose">Expose</a></li>
<li><a href="#Class">Class</a><ul>
<li><a href="#Class-Variables">Variables</a></li>
<li><a href="#Class-Functions">Functions</a></li>
<li><a href="#Class-Attribute-Modifier">Attribute Modifier</a><ul>
<li><a href="#Class-Attribute-Modifier-Public">Public</a></li>
<li><a href="#Class-Attribute-Modifier-Private">Private</a></li>
<li><a href="#Class-Attribute-Modifier-Protected">Protected</a></li>
<li><a href="#Class-Attribute-Modifier-Static">Static</a></li>
</ul>
</li>
<li><a href="#Class-Extends">Extends</a></li>
<li><a href="#Class-Implements">Implements</a></li>
<li><a href="#Class-Standard-Methods">Standard Methods</a><ul>
<li><a href="#Class-Standard-Methods-Init">Init</a></li>
<li><a href="#Class-Standard-Methods-Add">Add</a></li>
<li><a href="#Class-Standard-Methods-Subtract">Subtract</a></li>
<li><a href="#Class-Standard-Methods-Multiply">Multiply</a></li>
<li><a href="#Class-Standard-Methods-Divide">Divide</a></li>
<li><a href="#Class-Standard-Methods-Modulo">Modulo</a></li>
<li><a href="#Class-Standard-Methods-Valid">Valid</a></li>
<li><a href="#Class-Standard-Methods-Equal">Equal</a></li>
<li><a href="#Class-Standard-Methods-Less">Less</a></li>
<li><a href="#Class-Standard-Methods-Less-Equal">Less Equal</a></li>
<li><a href="#Class-Standard-Methods-Greater">Greater</a></li>
<li><a href="#Class-Standard-Methods-Greater-Equal">Greater Equal</a></li>
<li><a href="#Class-Standard-Methods-To-String">To String</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Interface">Interface</a></li>
<li><a href="#Async">Async</a><ul>
<li><a href="#Async-Then">Then</a></li>
<li><a href="#Async-Await">Await</a></li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="abstract">Abstract</h1>
<p>This document is the outline for the behaviour of Qupa&#39;s syntax, while it does also outline the syntax itself, there is a non-ambiguous BNF found <a href="./SyntaxOutline.html">here</a></p>
<h1 id="introduction">Introduction</h1>
<p>Note that spacing in the syntax examples are optional. As long as white space doesn&#39;t interfer with a string, or a namespace. White space is completely ignored.</p>
<h1 id="comment">Comment</h1>
<p>Comments are sections of code which are purely for the aid of the programmer, and are ignored at the interpretation stage.</p>
<h2 id="comment-single-line">Comment: Single line</h2>
<p>This type of code comment will ignore everything from the start of a <code>//</code> to a new line character.</p>
<p><strong>Syntax</strong></p>
<pre><code>// &lt;text&gt;\n</code></pre>
<h2 id="comment-multi-line">Comment: Multi Line</h2>
<p>This type of code comment will ignore everything from the start of a <code>/*</code> to a <code>*/</code> this can span multiple lines.</p>
<p><strong>Syntax</strong></p>
<pre><code>/* &lt;text&gt; */</code></pre>
<h1 id="constant">Constant</h1>
<p>Constants are assumed certain types based on their pattern. These types/patterns are described below</p>
<h2 id="constant-boolean">Constant: Boolean</h2>
<p>This constant is always resolved as if it is of a <a href="">boolean</a> class.</p>
<p><strong>Regex:</strong></p>
<pre><code class="trueregex">/(false|true)/w</code></pre>
<h2 id="constant-integer">Constant: Integer</h2>
<p>This constant is always resolved as if it is of a <a href="">i64</a> class.</p>
<p><strong>Regex:</strong></p>
<pre><code class="trueregex">/([0-9]{0,})/w</code></pre>
<h2 id="constant-double">Constant: Double</h2>
<p>This constant is always resolved as if it is of a <a href="">f64</a> class.</p>
<p><strong>Regex:</strong></p>
<pre><code class="trueregex">/([0-9]{1,})\.([0-9]{1,})/w</code></pre>
<p>or</p>
<pre><code>/([0-9]{1}\.[0-9]{1,})e(\+|\-)([0-9]{1,})/w</code></pre>
<p><strong>Examples:</strong></p>
<pre><code class="truequpa">123.45
1.2345e-2</code></pre>
<h2 id="constant-text">Constant: Text</h2>
<p>This constant will behave differently depending on which character you use to open and close it. If you use a single quote <code>&#39;</code>, then the constant data will be interpreted into a <a href="">string</a> class. Otherwise if a <code>&quot;</code> is used, then the data will interpreted into a <a href="">unicode</a> class.  </p>
<blockquote>
<p>Note that a <a href="">string</a> behaves presuming each character is 1 byte long, while <a href="">unicode</a> supports variable length characters, and thus UTF-8 support.<br>Both string and unicode implement the interface <code>text</code>.</p>
</blockquote>
<p><strong>Regex:</strong></p>
<pre><code class="trueregex">(&quot;)(.+)(?!\\&quot;)</code></pre>
<p>or</p>
<pre><code class="trueregex">(&#39;)(.+)(?!\\&#39;)</code></pre>
<h1 id="function">Function</h1>
<p>Functions are defined with a static return type, with zero to many function arguments. A function may only return once, attempting to return more than once will result in a runtime error.</p>
<p>The <code>type_rtrn</code> must be a classname accessible by the current scope.</p>
<p><strong>Syntax Definition:</strong></p>
<pre><code>&lt;type_rtrn&gt; &lt;func_name&gt; ( &lt;arguments&gt; ) {
  &lt;body&gt;
}</code></pre>
<p><strong>Syntax Call</strong></p>
<pre><code>&lt;func_name&gt; ( &lt;arguments&gt; )</code></pre>
<h2 id="function-argument">Function: Argument</h2>
<p>Function arguments must each have a type, and a name. Each argument must be delimetered by a <code>,</code>, however there must not be a trailing <code>,</code>.</p>
<p><strong>Syntax:</strong><br><code>type</code> can be a classname, or an interface available at the current scope. If the type is an interface it must be marked <a href="#Function-Argument-Upgrade">upgradable</a>, otherwise a compilation error will occur, as an interface is not a vaild variable type.</p>
<pre><code>&lt;type&gt; &lt;name&gt;</code></pre>
<pre><code>&lt;type&gt; &lt;name&gt;, &lt;type2&gt; &lt;name2&gt;</code></pre>
<h3 id="function-argument-default">Function: Argument: Default</h3>
<blockquote>
<p>Implementation Stage: Beta/Release</p>
</blockquote>
<p>Arguments may have a default value which it will posess if no value is specified at a call point. These values must be static constants, which are resolved at compile time.</p>
<p><strong>Syntax:</strong></p>
<pre><code>&lt;type&gt; &lt;name&gt; = &lt;constant&gt;</code></pre>
<h3 id="function-argument-upgrade">Function: Argument: Upgrade</h3>
<blockquote>
<p>Implementation Stage: Beta/Release</p>
</blockquote>
<p>A function argument&#39;s type can be marked as upgradable, meaning this function can be produce multiple methods for instances where it is called and parsed a child type.<br>For instance if you have <code>Student</code> as an extended class of <code>Person</code>, you may parse the student inplace of a <code>Person</code> argument.</p>
<pre><code class="truequpa">void SayHi (^Person person) {
  person.say(&quot;Hi&quot;)
}

void main () {
  Student example;
  SayHi(example);
}</code></pre>
<p><strong>Syntax:</strong></p>
<pre><code>^&lt;type&gt; &lt;name&gt;</code></pre>
<h2 id="function-method">Function: Method</h2>
<blockquote>
<p>Implementation Stage Pre-Alpha</p>
</blockquote>
<p>There can be multiple definitions under the same function definition within the same namespace. Each instance using that function name is refered to as a method. Each method must have a unique function signature, or else a interpretation error will occur.</p>
<h2 id="function-modifier">Function: Modifier</h2>
<blockquote>
<p>Implementation Stage Alpha</p>
</blockquote>
<p>Function modifiers are optional, however they change the compilation and execution behaviour of a function. Modifiers are listed by adding a <code>:</code> after the function name, then listing the modifiers afterwards. Note that multiple modifiers can be used via using a space <code> </code> as the deliminer.</p>
<p><strong>Syntax</strong></p>
<pre><code>&lt;type_rtrn&gt; &lt;name&gt;: &lt;modifier&gt; (&lt;arguments&gt;) {
  &lt;body&gt;
}</code></pre>
<h3 id="function-modifier-async">Function: Modifier: Async</h3>
<blockquote>
<p>Implementation Stage Alpha</p>
</blockquote>
<p>The <code>async</code> modifier specified this function will behave asynchnously. Meaning it can have delayed returns, interupted execution, and may continue execution due to cleanup or other listeners after returning. Further execution behaviour defined in <a href="#Async">async</a>.  </p>
<p>Note that the async modifier cannot be used at the same time as the <code>inline</code> modifier.</p>
<p><strong>Syntax:</strong></p>
<pre><code>&lt;type_rtrn&gt; &lt;name&gt;: async ( &lt;arguments&gt; ) {
  &lt;body&gt;
}</code></pre>
<h3 id="function-modifier-inline">Function: Modifier: inline</h3>
<blockquote>
<p>Implementation Release</p>
</blockquote>
<p>The <code>inline</code> deliminer specifies to the compiler to embed the behaviour of this function at the place of calling.</p>
<p><strong>Syntax:</strong></p>
<pre><code>&lt;type_rtrn&gt; &lt;name&gt;: inline ( &lt;arguments&gt; ) {
  &lt;body&gt;
}</code></pre>
<h2 id="function-template">Function: Template</h2>
<blockquote>
<p>Implementation Beta</p>
</blockquote>
<p>Allows the compile time generation of methods for this function based syntax input. Specifiers are declared similar to arguments - <code>&lt;type&gt; &lt;name&gt;</code>, however all types must be marked as <a href="#Function-Argument-Upgrade">upgradeable</a> and the name specified can then be used as a classname within the function arguments and body.</p>
<p>Note that the brackets of the specifier must be before any modifiers. Multiple specifiers are seperated via commas.</p>
<p><strong>Syntax: Definition</strong></p>
<pre><code>&lt;type_rtrn&gt; &lt;name&gt;[&lt;specifier&gt;] (&lt;arguments&gt;) {
  &lt;body&gt;
}</code></pre>
<pre><code>&lt;type_rtrn&gt; &lt;name&gt;[&lt;specifier&gt;]: async (&lt;arguments&gt;) {
  &lt;body&gt;
}</code></pre>
<p><strong>Syntax: Execution</strong></p>
<pre><code>&lt;name&gt;[&lt;specifier&gt;](&lt;arguments&gt;)</code></pre>
<h1 id="declare">Declare</h1>
<p>Variable can be defined in two scopes: global; and function. All definitions are raised to the top of the current scope. Thus if defining a varaible at any point within a function would be have the same as defining it at the beginning of the function.</p>
<p><strong>Syntax:</strong><br><code>type</code> must be a classname accessible to the current scope.</p>
<pre><code>&lt;type&gt; &lt;name&gt;</code></pre>
<h1 id="assign">Assign</h1>
<p>Assigns the result of an expression being resolved to a certain variable. How expressions are resolved are defined within <a href="#Expression">expression</a>.</p>
<p><strong>Syntax:</strong></p>
<pre><code>&lt;name&gt; = &lt;expr&gt;;</code></pre>
<h2 id="assign-short-hand">Assign: Short Hand</h2>
<blockquote>
<p>Implemented in beta stage</p>
</blockquote>
<p>Long form</p>
<pre><code>&lt;name&gt; = &lt;name&gt; &lt;opper&gt; ( &lt;expr&gt; );</code></pre>
<p>Short form</p>
<pre><code>&lt;name&gt; &lt;opper&gt;= &lt;expr&gt;;</code></pre>
<p>Operations that the short form can be applied to; <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></p>
<p><strong>Examples:</strong></p>
<pre><code class="truequpa">number += a;</code></pre>
<pre><code class="truequpa">number -= a;</code></pre>
<pre><code class="truequpa">number *= a;</code></pre>
<pre><code class="truequpa">number /= a;</code></pre>
<h1 id="if-statement">If statement</h1>
<p>The <a href="#Expression">expression</a> will be resolved according to the <a href="#Expression">expression</a> definition, then the resulting value will have it&#39;s <a href="#Class-standard-methods-valid">class validity check</a> ran. If the result is true, then the <code>&lt;body&gt;</code> code content will execute.</p>
<p>After execution of the <code>if</code> clause execution will continue after the last chain of the <code>if</code> statement. Be that the last <code>elif</code> clause, or the last <code>else</code> clause.</p>
<p><strong>Syntax:</strong></p>
<pre><code>if ( &lt;expr&gt; ) {
  &lt;body&gt;
}</code></pre>
<h2 id="if-elif">If: Elif</h2>
<p>These statement can be continued off of other <a href="#If-Statement">if statements</a> and other <a href="#IF-Elif">elif statements</a>, however it cannot exist anywhere else. This behaves similarly to an <code>if</code> statement, however it will only execute if the previous <code>if</code> and <code>elif</code> statement&#39;s conditions fail.</p>
<p>After execution of the <code>elif</code> clause execution will continue after the last chain of the <code>if</code> statement. Be that the last <code>elif</code> clause, or the last <code>else</code> clause.</p>
<p><strong>Syntax:</strong></p>
<pre><code>elif ( &lt;expr&gt; ) {
  &lt;body&gt;
}</code></pre>
<p><strong>Examples</strong></p>
<pre><code class="truequpa">if (false) {
  // will not execute
} elif (true) {
  // will execute
}</code></pre>
<h2 id="if-else">If: Else</h2>
<p>This statement can be continued off of any <a href="#If-Statement">if statements</a> or <a href="#IF-Elif">elif statements</a>, and will only execute the body code if the previous statement&#39;s conditions fail.</p>
<p>After execution of the <code>else</code> clause executione will continue after it&#39;s closing bracket.</p>
<p><strong>Syntax:</strong></p>
<pre><code>else {
  &lt;body&gt;
}</code></pre>
<p><strong>Examples</strong></p>
<pre><code class="truequpa">if (false) {
  // will not execute
} elif (false) {
  // will not execute
} else {
  // will execute
}</code></pre>
<h1 id="loop">Loop</h1>
<p>A loop repeats the <code>body</code> until the condition fails. The <code>condition</code> is an expression which resolves an <a href="#Expression">expression</a> and then checks <a href="#Class-Standard-Methods-Valid">validity</a>, this is tested before the execution of each loop.</p>
<h2 id="loop-for">Loop: For</h2>
<p>When a for loop starts will will first execute any <code>init</code> cases, it will then test the <code>condition</code>, from there it will repeatedly execute <code>condition -&gt; body -&gt; itterate</code> until condition fails, which will then execute the program continuing after the for loop.</p>
<p><code>init</code> can obtain any <a href="#Assign">assignment</a>, and multiple assignments can occur within this segment via seperating them with a comma. E.g. <code>i=0, j=1</code></p>
<p><code>itterate</code> this behaves similarly to <code>init</code>, however it executes each time the loop repeats, this can be triggered by reaching the end of the loop or a <a href="#Loop-Continue">continue</a> statement. E.g. <code>i += 1, j += 2</code></p>
<pre><code>for (&lt;init&gt;; &lt;condition&gt;; &lt;itterate&gt;) {
  &lt;body&gt;
}</code></pre>
<pre><code>&lt;lable&gt;: for (&lt;init&gt;; &lt;condition&gt;; &lt;itterate&gt;) {
  &lt;body&gt;
}</code></pre>
<h2 id="loop-while">Loop: While</h2>
<p><strong>Syntax:</strong></p>
<pre><code>while (&lt;condition&gt;) {
  &lt;body&gt;
}</code></pre>
<pre><code>&lt;lable&gt;: while (&lt;condition&gt;) {
  &lt;body&gt;
}</code></pre>
<h2 id="loop-break">Loop: Break</h2>
<p>This is immediatly (itterate will not execute) exit the loop block specified. If no block is specified then it exists the current depth loop. Otherwise the loop of which will be exited can be specified via the optional term <code>&lt;lable&gt;</code>.</p>
<p><strong>Syntax:</strong></p>
<pre><code>break</code></pre>
<pre><code>break &lt;lable&gt;</code></pre>
<h2 id="loop-continue">Loop: Continue</h2>
<p>This will jump straight to the itteration process to continue another loop. If no <code>&lt;lable&gt;</code> is specified then the continue will apply to the current loop.<br><strong>Syntax:</strong></p>
<pre><code>continue</code></pre>
<pre><code>continue &lt;lable&gt;</code></pre>
<h1 id="expression">Expression</h1>
<p>Expressions dictate how computation is resolved, and how arithmetic symbols are resolved. Most expression opperands are processed according to their <a href="#Class-Standard-Methods">standard class method</a>.  </p>
<p>The order of operations are (from first executed to last);<br>| Precedence | Operation | Syntax | Class Standard Method |<br>|:-|:-|:-|:-|<br>1 | Invert (aka Not) | <code>! &lt;opperand&gt;</code> | Yes<br>1 | Address | <code>@ &lt;variable_name&gt;</code> | -<br>2 | Addition | <code>&lt;opperand&gt; + &lt;opperand&gt; </code> | Yes<br>2 | Subtraction | <code>&lt;opperand&gt; - &lt;opperand&gt;</code> | Yes<br>3 | Multiplication | <code>&lt;opperand&gt; * &lt;opperand&gt;</code> | Yes<br>3 | Division | <code>&lt;opperand&gt; / &lt;opperand&gt;</code> | Yes<br>4 | Modulus | <code>&lt;opperand&gt; % &lt;opperand&gt;</code> | Yes<br>5 | And (boolean/set) | <code>&lt;opperand&gt; &amp;&amp; &lt;opperand&gt;</code> | Yes<br>5 | Or (boolean/set) | <code>&lt;opperand&gt; || &lt;opperand&gt;</code> | Yes<br>6 | Function calls (Async) | <a href="#Async-Await">definition</a> | -<br>6 | Function calls (Sync) | <a href="#Function">definition</a> | -<br>7 | Brackets | <code>( &lt;expr&gt; )</code> | -</p>
<h1 id="import">Import</h1>
<p>Allows access to variables and functions exposed within another file. The compiler will always search the local scopes first, before trying to resolve to names within other files.  </p>
<p>The front end compiler is multiparse, thus it loads all required files and interprets all variable, function and class declarations before resolving any namespaces, or compiling any behvaiour. Thus importations can have circular references. i.e. <code>A imports B; B imports C; C imports A</code> </p>
<p>Also note that all import filepaths are relative to the current file.</p>
<h2 id="import-direct">Import: Direct</h2>
<p>If a variable or function call cannot be resolved within the current file scope, the compiler will search within libraries imported into the current file scope.</p>
<p><strong>Syntax</strong></p>
<pre><code>import &quot;&lt;filepath&gt;&quot;</code></pre>
<h2 id="import-as">Import: As</h2>
<p>All exposed namepsaces within the imported file are only accessible under the namespace provided.<br><strong>Example:</strong></p>
<pre><code class="truequpa">import &quot;library.qp&quot; as library
library.HelloWorld();</code></pre>
<p><strong>Syntax</strong></p>
<pre><code>import &quot;&lt;filepath&gt;&quot; as &lt;namespace&gt;</code></pre>
<h1 id="expose">Expose</h1>
<p>Exposing a namespace allows the variable/function/class/interface to be accessed when imported in another file. If a namespace is not exposed then it cannot be accessed on importation.</p>
<pre><code>expose &lt;namespace&gt;</code></pre>
<h1 id="class">Class</h1>
<blockquote>
<p>Implementation Stage: Particial implementation by alpha, full implementation by release.</p>
</blockquote>
<p>Classes tie behaviour to data, and allow the accessing of class functions in scopes where the original class definition may not be available. It also allows for polymorphic programming, decreasing on duplicate code increasing project readability and maintainability.</p>
<blockquote>
<p>Note that the name of classes can be used wherever <code>&lt;type&gt;</code> is used in a syntax outline within this document.</p>
</blockquote>
<p><strong>Syntax:</strong></p>
<pre><code>class &lt;namespace&gt; {

}</code></pre>
<h2 id="class-variables">Class: Variables</h2>
<p>Definining a variable within a class will define a class attribute</p>
<p><strong>Syntax:</strong><br>Same as variable <a href="#Declare">declaration</a> however it must be within a class.</p>
<h2 id="class-functions">Class: Functions</h2>
<p>Defines a class method, within any non-static function the namespace <code>this</code> refers to a pointer which points to a class instance or a child class instance. (Includes children of children)</p>
<p><strong>Syntax: Declaration</strong><br>Same as a normal <a href="#Function">function</a> however it must be within a class block.</p>
<p><strong>Syntax: Call</strong><br>Similar to <a href="#Function">function</a> however the class instance must be specified. Note that this behaviour is changed when the function has the <a href="#Class-Attribute-Modifier-Static">static modifier</a> applied to it. In that case <code>&lt;class_instance&gt;</code> should be replaced with the class&#39; name.</p>
<pre><code>&lt;class_instance&gt;.&lt;function_name&gt;( &lt;argments&gt; )</code></pre>
<h2 id="class-attribute-modifier">Class: Attribute Modifier</h2>
<p>Class attribute modifiers maybe declared at anypoint with class scope (not within any function&#39;s scope). They will then apply to all attributes and functions below them. Note that public/private/protected override eachother&#39;s behaviour - while static&#39;s affects cannot be removed. Thus all static variables/attributes must be at the bottom of the class body.</p>
<h3 id="class-attribute-modifier-public">Class: Attribute Modifier: Public</h3>
<p>This is the default state of all attributes/methods, which means they accessible by any class function, or any external function.</p>
<p><strong>Syntax</strong></p>
<pre><code>class &lt;namespace&gt; {
  public:
}</code></pre>
<h3 id="class-attribute-modifier-private">Class: Attribute Modifier: Private</h3>
<p>This means the attributes/methods may only be accessed by this class/interface, or any class which upgrades it.</p>
<p><strong>Syntax</strong></p>
<pre><code>class &lt;namespace&gt; {
  private:
}</code></pre>
<h3 id="class-attribute-modifier-protected">Class: Attribute Modifier: Protected</h3>
<p>This means the attributes/methods can only be accessed by this class, and not any class which extends it.<br>Note that if another instance of this class accessed by a method of this class, it can also access it&#39;s protected attributes.</p>
<p><strong>Syntax</strong></p>
<pre><code>class &lt;namespace&gt; {
  protected:
}</code></pre>
<h3 id="class-attribute-modifier-static">Class: Attribute Modifier: Static</h3>
<p>This means there is only one instance of this method/attribute for all instances.</p>
<p>Hence a static variable behaves similar to a global variable, however it may not be accessible by other methods/classes depedning what other modifiers are acting on it (public/private/protected).</p>
<p>A static function behaves instead much more like a normal function, and does not possess a <code>this</code> variable within it&#39;s local scope. However it can still access any <code>private</code>/<code>protected</code> variables this class should have access to.</p>
<p><strong>Syntax</strong></p>
<pre><code>class &lt;namespace&gt; {
  static:
}</code></pre>
<h2 id="class-extends">Class: Extends</h2>
<p>This will cause the new class to duplicate all of the attributes/methods from the exention class to this one. Note that in every case <code>this</code> will be upgraded to the new class type.<br>Also note that methods will not be copied if they are replaced within the new class.</p>
<p><strong>Syntax:</strong><br>A class may only have one extention clause, the exention clause must be after the class name</p>
<pre><code>class &lt;namespace&gt; extends &lt;class&gt; {
  &lt;body&gt;
}</code></pre>
<h2 id="class-implmenents">Class: Implmenents</h2>
<p>This defines that this class will implement all features (methods/attributes) that the interface specified has defined. If an attribute or function is not implemented within this class, that is declared within the interface the compiler will throw an error and will fail to compile.</p>
<p>A single class can implement multiple interfaces, any interface that the class implements - this class will not be considered an upgrade of the interface.</p>
<p><strong>Syntax:</strong><br>The implements clause must be after the class name, and after any extention.  </p>
<pre><code>class &lt;namespace&gt; extends &lt;class&gt; implements &lt;interface&gt; {
  &lt;body&gt;
}</code></pre>
<p>For multiple interfaces they must be surrounded by square brackets <code>[]</code>, and there must be a comma after each interface</p>
<pre><code>class &lt;namespace&gt; extends &lt;class&gt; implements [ &lt;interface1&gt;, &lt;interface2&gt; ] {
  &lt;body&gt;
}</code></pre>
<h2 id="class-template">Class: Template</h2>
<p>This allows for dynamically generation of multiple versions of this class, each with customizeable structure and methods. This behaviour is very similar to <a href="#Function-Template">function templates</a>.</p>
<p>Specifiers are declared similar to arguments - <code>&lt;type&gt; &lt;name&gt;</code>, however all types must be marked as <a href="#Function-Argument-Upgrade">upgradeable</a> and the name specified can then be used as a classname within the class body.</p>
<p>When a class is defined in template form, the namespace itself assumes the form of an interface, which then all versions of the class generated then implement said interface, and extend the defined class if extend clause is present.</p>
<p><strong>Syntax Definition:</strong><br>The specification must be defined before any <a href="#Class-Extends">extends</a> or <a href="#Class-Implements">implmenents</a> clauses and after the class&#39; namespace.</p>
<p>One class may have multiple specifiers via seperating them with a comma.</p>
<pre><code>class &lt;namespace&gt;[&lt;specifier&gt;] {
  &lt;body&gt;
}</code></pre>
<p><strong>Syntax Use:</strong><br><code>namespace</code> is the name of a template class available within the current scope.<br><code>type</code> must be a classname available within the current scope.</p>
<pre><code>&lt;namespace&gt;[&lt;type&gt;]</code></pre>
<h2 id="class-standard-methods">Class: Standard Methods</h2>
<p>Standard methods are methods used within <a href="#Expression">expressions</a> to handle operators. These are not compulsory (except init), unless specified in an interface that is being implemented.<br>They also may have any modifiers on them unless specified otherwise.</p>
<p>It is assumed that these methods return a new class instance, rather than altering the existing instance they were called upon. I.e. <code>a.__add__(b)</code> should not alter <code>a</code> but instead return a new value for the result.</p>
<h3 id="class-standard-methods-init">Class: Standard Methods: Init</h3>
<p>Init may <strong>not</strong> have the async specifier on it.</p>
<pre><code>class &lt;namespace&gt; {
  void __init__ (&lt;attributes&gt;) {

  }
}</code></pre>
<h3 id="class-standard-methods-get">Class: Standard Methods: Get</h3>
<pre><code>class &lt;namespace&gt; {
  &lt;classname&gt; __get__ (&lt;attributes&gt;) {

  }
}</code></pre>
<h3 id="class-standard-methods-invert">Class: Standard Methods: Invert</h3>
<pre><code>class &lt;namespace&gt; {
  &lt;namespace&gt; __invert__ () {

  }
}</code></pre>
<h3 id="class-standard-methods-and-booleanset">Class: Standard Methods: And (boolean/set)</h3>
<pre><code>class &lt;namespace&gt; {
  &lt;namespace&gt; __and__ (&lt;classname&gt; &lt;variable_1&gt;) {

  }
}</code></pre>
<h3 id="class-standard-methods-or-booleanset">Class: Standard Methods: Or (boolean/set)</h3>
<pre><code>class &lt;namespace&gt; {
  &lt;namespace&gt; __or__ (&lt;classname&gt; &lt;variable_1&gt;) {

  }
}</code></pre>
<h3 id="class-standard-methods-add">Class: Standard Methods: Add</h3>
<pre><code>class &lt;namespace&gt; {
  &lt;namespace&gt; __add__ (&lt;classname&gt; &lt;variable_1&gt;) {

  }
}</code></pre>
<h3 id="class-standard-methods-subtract">Class: Standard Methods: Subtract</h3>
<pre><code>class &lt;namespace&gt; {
  &lt;namespace&gt; __subtact__ (&lt;classname&gt; &lt;variable_1&gt;) {

  }
}</code></pre>
<h3 id="class-standard-methods-multiply">Class: Standard Methods: Multiply</h3>
<pre><code>class &lt;namespace&gt; {
  &lt;namespace&gt; __multiply__ (&lt;classname&gt; &lt;variable_1&gt;) {

  }
}</code></pre>
<h3 id="class-standard-methods-divide">Class: Standard Methods: Divide</h3>
<pre><code>class &lt;namespace&gt; {
  &lt;namespace&gt; __divide__ (&lt;classname&gt; &lt;variable_1&gt;) {

  }
}</code></pre>
<h3 id="class-standard-methods-modulo">Class: Standard Methods: Modulo</h3>
<pre><code>class &lt;namespace&gt; {
  &lt;namespace&gt; __modulo__ (&lt;classname&gt; &lt;variable_1&gt;) {

  }
}</code></pre>
<h3 id="class-standard-methods-valid">Class: Standard Methods: Valid</h3>
<pre><code>class &lt;namespace&gt; {
  bool __modulo__ () {

  }
}</code></pre>
<h3 id="class-standard-methods-equal">Class: Standard Methods: Equal</h3>
<pre><code>class &lt;namespace&gt; {
  &lt;namespace&gt; __equal__ (&lt;classname&gt; &lt;variable_1&gt;) {

  }
}</code></pre>
<h3 id="class-standard-methods-less">Class: Standard Methods: Less</h3>
<pre><code>class &lt;namespace&gt; {
  &lt;namespace&gt; __less__ (&lt;classname&gt; &lt;variable_1&gt;) {

  }
}</code></pre>
<h3 id="class-standard-methods-less-equal">Class: Standard Methods: Less Equal</h3>
<pre><code>class &lt;namespace&gt; {
  &lt;namespace&gt; __lessEqual__ (&lt;classname&gt; &lt;variable_1&gt;) {

  }
}</code></pre>
<h3 id="class-standard-methods-greater">Class: Standard Methods: Greater</h3>
<pre><code>class &lt;namespace&gt; {
  &lt;namespace&gt; __greater__ (&lt;classname&gt; &lt;variable_1&gt;) {

  }
}</code></pre>
<h3 id="class-standard-methods-greater-equal">Class: Standard Methods: Greater Equal</h3>
<pre><code>class &lt;namespace&gt; {
  &lt;namespace&gt; __greaterEqual__ (&lt;classname&gt; &lt;variable_1&gt;) {

  }
}</code></pre>
<h3 id="class-standard-methods-to-string">Class: Standard Methods: To String</h3>
<p>Note that <code>&lt;text&gt;</code> may be of any type that is an upgrade from <code>text</code>.</p>
<pre><code>class &lt;namespace&gt; {
  &lt;text&gt; __modulo__ () {

  }
}</code></pre>
<h1 id="interface">Interface</h1>
<blockquote>
<p>Note that the name of interfaces can be used wherever <code>&lt;type&gt;</code> is used in a syntax outline within this document.</p>
</blockquote>
<h1 id="async">Async</h1>
<p>A sync class declaration is defined in the <a href="#Function-Modifier-Async">function outline</a>. This segment outlines the change in execution behaviour and where async functions can and cannot be executed.</p>
<p>An async function can only be executed normally within another async function. Async functions may have a large time delay between call and return, and also multiple other processes may take process within the current thread between call and return on an execution.</p>
<h2 id="async-then">Async: Then</h2>
<blockquote>
<p>Implementation stage alpha</p>
</blockquote>
<p>The execution of a then clause occurs when function execution has finished.<br><strong>Syntax:</strong></p>
<pre><code>&lt;namespace&gt;(&lt;attributes&gt;) then {
  &lt;body&gt;
}</code></pre>
<p>The return value can be written to a local varaible via the syntax below. Note until the return event occurs, no alterations will occur to this variable.</p>
<pre><code>&lt;namespace&gt;(&lt;attributes&gt;) then -&gt; &lt;namespace2&gt; {
  &lt;body&gt;
}</code></pre>
<h2 id="async-await">Async: Await</h2>
<blockquote>
<p>Implementation stage beta</p>
</blockquote>
<p>This will pause the execution of the current method until the return of the called function. The result of which will then be parsed inline similar to the normal behaviour of function. Thus via the use of the await term async functions can be used within expressions.</p>
<p><strong>Syntax:</strong></p>
<pre><code>await &lt;namespace&gt;(&lt;attributes&gt;)</code></pre>
<span class="tags"><h6 style="display: inline-block;">Tags:</h6><a href="/tag/specification.html"><tag>Specification;</tag></a><a href="/tag/qupa.html"><tag>Qupa;</tag></a></span></div><footer>
	<button id="Toggle-Dark-Theme">Dark Theme</button><br>
	<a href="/rss/all.rss">RSS Feed</a>
</footer></body></html>